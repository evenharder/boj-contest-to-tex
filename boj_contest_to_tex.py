from bs4 import BeautifulSoup

class SpotboardAnalyzer:
    '''
    A data structure handling Spotboard json data.
    '''

    def __init__(self, contest_json, runs_json):
        '''
        Constructor.

        contest_json
          dict from Spotboard 'contest.json'.
        runs_json
          dict from Spotboard 'runs_json'.
        '''
        self.contest_json = contest_json
        self.runs_json = runs_json
        self.problems = contest_json['problems']
        self.teams = contest_json['teams']
        self.team_ac = {team['id']: set() for team in self.teams}

    def generate_run_data(self, *, problem_list=None, interval=5, contest_time=None, is_frozen=False):
        '''
        Return run data as a list where the first item includes labels,
        and the others contain timeframe and the number of each verdict
        (yes, no, pending).

        Generated run data, if printed, is compatible with
        LaTex pgfplots datatable format.

        Figures of No verdict are negated to display No submissions as
        negative stacked bar in LaTeX.

        problem_list
          list of desired spotboard problem ids, defaults to all problems.
        interval
          interval between timeframes starting from 0min, defaults to 5
        contest_time.
          total contest time for data,
          defaults to whole contest time based on contest_json.
        is_frozen
          whether to display frozen subs as frozen, default to False.
        '''
        if problem_list is None:
            problem_list = [problem['id'] for problem in self.problems]
        if contest_time is None:
            contest_time = self.runs_json['time']['contestTime'] // 60
        self.team_ac = {team['id']: set() for team in self.teams}

        run_data = [['Interval', 'Yes', 'No', 'Pending']]
        for t in range(0, contest_time + 1, interval):
            run_data.append([t, 0, 0, 0])
        runs = self.runs_json['runs']
        for cur_run in runs:
            if cur_run['problem'] not in problem_list:
                continue
            if cur_run['problem'] in self.team_ac[cur_run['team']]:
                continue
            tid = cur_run['submissionTime'] // interval + 1
            if cur_run['frozen'] and is_frozen:
                run_data[tid][3] += 1
            elif cur_run['result'] == 'Yes':
                run_data[tid][1] += 1
                self.team_ac[cur_run['team']].add(cur_run['problem'])
            else:
                run_data[tid][2] -= 1
        for i in range(len(run_data)):
            run_data[i] = [str(x) for x in run_data[i]]
        return run_data

    def export_run_data(self, run_data, path):
        '''
        Export run data to a file.

        run_data:
          a list generated by generate_run_data.
        path:
          path to export file
        '''
        with open(path, 'w') as f:
            for line in run_data:
                f.write('\t'.join(line))
                f.write('\n')

    def print_run_data(self, run_data):
        '''
        Print run data to stdout.

        run_data
          a list generated by generate_run_data.
        '''
        for line in run_data:
            print('\t'.join(line))

    def export_full_data(self, filename_prefix, **kwargs):
        '''
        Generate and export run data for all submissions regardless of problem id,
        as well as run data for each problem.

        filename_prefix
          path prefix for generated files.
        **kwargs
          keyword arguments directly passed to generate_run_data.
        '''
        problem_lists = []
        for problem in self.problems:
            problem_lists.append([problem['id']])
        problem_lists.append([problem['id'] for problem in self.problems])

        filenames = []
        for problem in self.problems:
            filenames.append(f'{filename_prefix}-{problem["name"]}.txt')
        filenames.append(f'{filename_prefix}-@.txt')

        for problem_list, filename in zip(problem_lists, filenames):
            self.export_run_data(self.generate_run_data(
                problem_list=problem_list, **kwargs), filename)


class BOJStatisticsAnalyzer:
    '''
    A data structure which easily converts BOJ Statistics to LaTeX format,
    especially aligned with UCPC editorial. 
    '''
    class BOJContestProblem:
        def __init__(self):
            self.id = None
            self.name = None
            self.ac_num = None
            self.ac_ratio = None
            self.total_sub = None
            self.fs_time = '-'
            self.fs_teamname = '-'
            self.fs_teammate = '-, -, -'

        def __repr__(self):
            return f'''{self.id} - {self.name}
{self.ac_num}/{self.total_sub} ({self.ac_ratio})
First solve : {self.fs_teamname}, {self.fs_teammate}, {self.fs_time}'''

    def __init__(self, html_page):
        '''
        Constructor.

        Support only BOJ team contest page as of now.

        html_page
          str object indicating html of BOJ Contest statistics page.
        '''
        soup = BeautifulSoup(html_page, 'html.parser')
        arr = soup.get_text(separator='\n', strip=True).split('\n')

        def index_r(arr, start, *args):
            ind = start
            for arg in args:
                if ind == -1:
                    return -1
                ind = arr.index(arg, start) + 1
            return ind if ind < len(arr) else -1

        contest_title = arr[0][:-5].strip()
        prob_nums = (index_r(arr, 1, contest_title, '합계') -
                     index_r(arr, 1, contest_title, '문제 통계') - 1)
        self.boj_probs = [self.BOJContestProblem() for _ in range(prob_nums)]
        prob_index = index_r(arr, 1, contest_title, '질문')
        for i in range(prob_nums):
            j = prob_index + 2 * i
            self.boj_probs[i].id = arr[j].strip()
            self.boj_probs[i].name = arr[j + 1][1:].strip()
        ac_index = index_r(arr, prob_index, '맞은 사람')
        for i in range(prob_nums):
            j = ac_index + i
            self.boj_probs[i].ac_num = arr[j].strip()
        ac_ratio_index = index_r(arr, ac_index, '정답율')
        for i in range(prob_nums):
            j = ac_ratio_index + i
            self.boj_probs[i].ac_ratio = arr[j].strip()
        total_sub_index = index_r(arr, ac_index, '총 제출')
        for i in range(prob_nums):
            j = total_sub_index + i
            self.boj_probs[i].total_sub = arr[j].strip()
        fs_index = index_r(arr, total_sub_index, '맞았습니다')
        prob_index = 0
        while True:
            if arr[fs_index].find('-') == -1:
                break
            bar_index = arr[fs_index].find('-')
            cur_id = arr[fs_index][:bar_index - 1].strip()
            cur_name = arr[fs_index][bar_index + 1:].strip()
            while prob_index < len(self.boj_probs) and \
                self.boj_probs[prob_index].id != cur_id or \
                    self.boj_probs[prob_index].name != cur_name:
                prob_index += 1
            if prob_index == len(self.boj_probs):
                break
            cur_prob = self.boj_probs[prob_index]
            team_par_index = -arr[fs_index + 2][::-1].find('(') - 1
            cur_prob.fs_teamname = arr[fs_index + 2][:team_par_index].strip()
            cur_prob.fs_teammate = arr[fs_index + 2][team_par_index:].strip()
            cur_prob.fs_time = arr[fs_index + 3][1:].strip()
            fs_index += 4

    def print_beamer_style(self, *, tab_size=4, is_space=True, fd=None):
        '''
        print parsed and analyzed statistics page in UCPC beamer editorial format.

        tab_size
          number of space for indentation, defaults to 4.
        is_space
          whether to use space of tab, defaults to True (space).
        fd
          a file-like object (stream) passed to print,
          defaults to current sys.stdout.
        '''
        def ratio_conv(ratio):
            return ratio[:-1] + "\%"
        for boj_prob in self.boj_probs:
            indent = ' ' * tab_size if is_space else '\t'
            if int(boj_prob.ac_num):
                fs_data = rf'\textbf{{{boj_prob.fs_teamname}}} {boj_prob.fs_teammate}, {boj_prob.fs_time}'
            else:
                fs_data = '--'
            print(rf'''{indent}% {boj_prob.id} - {boj_prob.name}
{indent}\begin{{itemize}}
{indent}{indent}\item 제출 {boj_prob.total_sub}번, 정답 {boj_prob.ac_num}팀 (정답률 {ratio_conv(boj_prob.ac_ratio)})
{indent}{indent}\item 처음 푼 팀: {fs_data} 
{indent}{indent}\item 출제자: \texttt{{placeholder}}
{indent}\end{{itemize}}
''', file=fd)


if __name__ == '__main__':
    pass